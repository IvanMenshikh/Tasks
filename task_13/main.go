package main

// На вход сервису поступают обновления документов
//
// в формате protobuf
// message TDocument {
//     string Url = 1;  // URL документа, его уникальный идентификатор
//     uint64 PubDate = 2;  // время заявляемой публикации документа
//     uint64 FetchTime = 3; // время получения данного обновления документа, может рассматриваться как идентификатор версии. Пара (Url, FetchTime) уникальна.
//     string Text = 4; // текст документа
//     uint64 FirstFetchTime = 5; // изначально отсутствует, необходимо заполнить
// }
//
// Документы могут поступать в произвольном порядке (не в том, как они обновлялись),
// также возможно дублирование отдельных сообщений.

// Необходимо на выходе формировать такие же сообщения, но с исправленными отдельными полями
// по следующим правилам (всё нижеуказанное - для группы документов с совпадающим полем Url):
// - Поле `Text` и `FetchTime` должны быть такими, какими были в документе с наибольшим `FetchTime` на данный момент
// - Поле `PubDate` должно быть таким, каким было у сообщения с наименьшим `FetchTime`
// - Поле `FirstFetchTime` должно быть равно минимальному значению `FetchTime`
//
// То есть в каждый момент времени мы берём `PubDate` и `FirstFetchTime` от самой первой из полученных
// на данный момент версий (если отсортировать их по `FetchTime`), а `Text` - от самой последней.
//
// Данный код будет работать в сервисе, читающим входные сообщения из очереди сообщений (Kafka или подобное),
// и записывающем результат также в очередь. Если `Process` возвращает `nil` - то в очередь ничего не пишется.
//
//
// Интерфейс в коде можно реализовать таким:

// package service

// type Processor interface {
//     Process(ctx context.Context, doc *Document) (*Document, error)
// }

// func (p *Processor) Process(ctx conttext.Context, doc *Document) (*Document, error) {
//   //
// }

// Данный код будет работать в сервисе, читающим входные сообщения из очереди сообщений (Kafka или подобное),
// и записывающем результат также в очередь. Если Process возвращает Null - то в очередь ничего не пишется.

func main() {}
