package main

import (
	"fmt"
)

//Что выведет программа? : [2 4 6 8]
//Почему именно такой результат? : Изменяем элементы на месте через индекс, а append создает новый слайс, не изменяя исходный
//Как изменится вывод, если заменить s := []int{1, 2, 3, 4} на s := make([]int, 4, 4)? : будет [0 0 0 0] потому что слайс создан с нуля и заполнен нулями
//Что произойдёт, если в modifySlice сделать s[0] = 999 перед append? : будет [999 2 3 4]
//Как сделать так, чтобы append внутри modifySlice влиял на исходный слайс? : Передавать указатель на слайс или возвращать новый слайс из функции ([]int + return s)
// ----------------------
// func modifySlice(s []int) {
// 	for i := range s {
// 		s[i] = s[i] * 2
// 	}
// 	s = append(s, 100) // добавляем новый элемент
// }

// func main() {
// 	//s2 := make([]int, 4, 4)
// 	s := []int{1, 2, 3, 4}
// 	modifySlice(s)
// 	fmt.Println(s)
// }
// ----------------------

func modifySlice(s *[]int) {
	for i := range *s {
		(*s)[i] *= 2
	}
	*s = append(*s, 100) // добавляем новый элемент
}

func main() {
	s := []int{1, 2, 3, 4}
	modifySlice(&s)
	fmt.Println(s)
}
